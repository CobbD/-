#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS:[11pt,oneside]
#+LATEX_HEADER: \usepackage{article}


#+TITLE: re模块
#+AUTHOR: 万泽(德山书生)
#+CREATOR: wanze(<a href="mailto:a358003542@gmail.com">a358003542@gmail.com</a>)
#+DESCRIPTION: 制作者邮箱：a358003542@gmail.com



\chapter{re模块}
\label{sec:re模块}
re模块提供了python对于正则表达式的支持，对于字符串操作，如果之前在介绍字符串类型的一些方法（比如split，replace等等），能够用它们解决问题就用它们，因为更快更简单。实在需要动用正则表达式理念才考虑使用re模块，而且你要克制写很多或者很复杂的（除非某些特殊情况）正则表达式的冲动，因为正则表达式的引入将会使得整个程序都更加难懂和不可捉摸。

\begin{large}
更多内容请参见\href{https://docs.python.org/3/library/re.html}{官方文档}。
\end{large}

\section{re模块中的元字符集}
\begin{description}
\item[\emph{.}] 表示一行内的任意字符，如果如果通过re.compile指定\textbf{re.DOTALL}，则表示多行内的任意字符，即包括了换行符。此外还可以通过字符串模板在它的前面加上\textbf{(?s)}来获得同样的效果。
\item[\emph{*}] 对之前的字符匹配\uwave{零次}或者多次。
\item[\emph{+}] 对之前的字符匹配\uwave{一次}或者多次。
\item[\emph{?}] 对之前的字符匹配\uwave{零次}或者\uwave{一次}。
\item[\emph{\{m\}}] 对之前的字符匹配(\uwave{exactly})m次。
\item[\emph{\{m,n\}}] 对之前的字符匹配m次到n次，其中n次可能省略，视作默认值是无穷大。
\item[\emph{\^{}}] 表示字符串的开始，如果加上\textbf{re.MULTILINE}选项，则表示行首。此外字符串模板加上\textbf{(?m)}可以获得同样的效果。
\item[\emph{\${}}] 表示字符串的结束，同\^{}类似，如果加上\textbf{re.MULTILINE}选项，则表示行尾，可以简单理解为\verb+\n+换行符。此外字符串模板加上\textbf{(?m)}可以获得同样的效果。

\${}符号在re.sub函数中可以被替换为另外一个字符串，其具体效果就是原字符串尾加上了这个字符串，类似的\^{}被替换成某个字符串，其具体效果就是原字符串头加上了这个字符串。这里显然\^{}和\${}在字符串中都不是真实存在的字符，而没有这个所谓的标记，所以这种替换总给人怪怪的感觉。
\item[\emph{[]}] [abc]字符组匹配一个字符，这个字符是a或者b或者c。类似的[a-z]匹配所有的小写字母，\verb+[\w]+匹配任意的字母或数字，具体请看下面的特殊字符类。
\item[\emph{|}] 相当于正则表达式内的匹配或逻辑。
\item[\emph{()}] 圆括号包围的部分将会记忆起来，方便后面调用。这个后面在谈及。
\end{description}



\section{re模块中的特殊字符类}
\begin{Verbatim}
\w  任意的字母或数字  [a-zA-Z0-9_]  (meaning word)
\W  匹配任何非字母非数字 [^a-zA-Z0-9_]
\d   [0-9]   (digit) 数字
\D  [^0-9] 非数字
\s   匹配任何空白字符   [ \t\n\r\f\v] 。
\S  匹配任何非空白字符
匹配中文:[\u4e00-\u9fa5]
\b  文档说严格的定义是\w 和\W 之间的边界，反之亦然。粗略的理解可以看作是英文单词头或者尾。
\end{Verbatim}

其中\^{}在方括号[]里面，只有在最前面，才表示排除型字符组的意思。


\section{转义问题}
正则表达式的转义问题有时会比较纠结。一个简单的原则是以上谈及的有特殊作用的字符有转义问题，如果python中的字符都写成\verb+r''+这种形式，也就是所谓的raw string形式，这样\verb+\n+在里面就可以直接写成\verb+\n+，而\verb+\section+可以简单写为\verb+\\section+即可，也就是\verb+\+字符需要转义一次。

然后字符组的方括号内[]有些字符有时是不需要转义的，这个实在不确定就转义吧，要不就用Kiki测试一下。


\section{re模块的使用}
compile方法生成regular expression object这一条线这里略过了，接下来的讨论全部基于（原始的）字符串模板。

字符串模板前面提及(?m)和(?s)的用法了，然后\textbf{(?i)}表示忽略大小写。

\subsection{匹配和查找}
search，match方法简单地用法就是：
\begin{Verbatim}
re.search(字符串模板, 待匹配字符串)
re.match(pattern, string)
\end{Verbatim}

它们将会返回一个match object或者none，其中match object在逻辑上就是真值的意思。match对字符串的匹配是必须从一开始就精确匹配，这对于正则表达式多少0有点突兀。推荐使用search方法，如果一定要限定行首，或者字符串开始可以用前面讨论的正则表达式各个符号来表达。请看下面的例子。

\begin{tcbpython}[]
import re
string = '''this is test line.
this is the second line.
today is sunday.'''

match = re.search('(?m)^today',string)

if match:
    print('所使用的正则表达式是：',match.re)
    print('所输入的字符串是：',match.string)
    print('匹配的结果是：',match.group(0))
    print('匹配的字符串index',match.span())
else:
    print('return the none value')
\end{tcbpython}

前面说道圆括号的部分将会记忆起来，作为匹配的结果，默认整个正则表达式所匹配的全部是group中的第0个元素，然后从左到右，子group编号依次是1，2，3......。

\begin{Verbatim}
所使用的正则表达式是： re.compile('(?m)^today', re.MULTILINE)
所输入的字符串是： this is test line.
this is the second line.
today is sunday.
匹配的结果是： today
匹配的字符串index (44, 49)
\end{Verbatim}

具体这些信息是为了说明情况，实际最简单的情况可能就需要判断一下是不是真值，字符串模板是不是匹配到了即可。


\subsection{分割操作}
re模块的split函数可以看作字符串的split方法的升级版本，对于所描述的任何正则表达式，匹配成功之后都将成为一个分隔符，从而将原输入字符串分割开来。

下面是我写的zwc小脚本的最核心的部分，用途是统计中英文文档的具体英文单词和中文字符的个数。其中最核心的部分就是用的re的split函数进行正则表达式分割，如果不用那个圆括号的话，那么分隔符是不会包含进去的，这里就是具体匹配的中文字和各个标点符号等等。用了圆括号，那么圆括号匹配的内容也会进去列表。这里就是具体的各个分隔符。

\begin{tcbpython}[]
import re

def zwc(string):
    #中英文常用标点符号
    lst = re.split('([\u4e00-\u9fa5\s，。；])',string)
    #去除 空白
    #去除\s 中英文常用标点符号
    lst = [i for i in lst if not  i in
    [""," ","\n","\t","\r","\f","\v","；","，","。"]]
    print(lst)

if __name__ == '__main__':
    string='''道可道，非常道。名可名，非常名。無名天地之始，有名萬物之母。
    故常無欲，以觀其妙；常有欲，以觀其徼。此兩者同出而異名，
    同謂之玄，玄之又玄，眾妙之門。 '''
    zwc(string)
\end{tcbpython}

字符分割之后后面做了一个小修正，将匹配到的空白字符和中英文标点符号等都删除了，这些是不应该统计入字数的。

具体这个github项目链接在这里：\href{https://github.com/a358003542/zwc}{zwc项目}。


\subsection{替换操作}
基于正则表达式的替换操作非常的有用，其实前面的search方法，再加上具体匹配字符串的索引值，然后修改原字符串，然后再search这样循环操作下去，就是一个替换操作了。re模块有sub方法来专门解决这个问题。

让我们为Linux系统写一个resub命令，这个命令的用途就是将某一个标准输入流或者utf-8文本文件按照你定义的正则表达式规则，依次完成一个\footnote{这里简单起见就是一个，多个情况可以考虑编写另外一个程序来控制之。}正则表达式文本替换工作。这个命令在我们需要对某个utf-8文本文件进行某个你想要的——非简单的精确相同匹配然后替换操作时——特别有用。

为了作为程序的检验，这里提出两个任务：第一个任务是我们在ocr PDF文档之后的输出，经常发现很多标点符号问题，这些需要人手工修改会非常的耗费精力。其中第一个问题如下，"这是一段文字"需要替换成为“这是一段文字”。这个例子之所以特别是因为中文的双引号是分左和右的，这里必须要用正则表达式匹配和替换；第二个任务更加的复杂，那就是从排版角度上讲，如果括号里面的文字都是英文或者数字，那么就使用英文的括号()，如果括号里面有中文或者全是中文\footnote{这里程序的逻辑是都换成中文的全角括号（毕竟中文unicode码具体范围的判断是不太精确的），只有那些纯英文纯数字或者基本英文标点和其他简单符号的再换成英文括号}，那么就使用中文的括号（）。ocr出来或者甚至人编写的文档都常常难以做到没有瑕疵，第二个任务就是通过resub命令来确保之后的输出文档的括号满足这一要求。

然后程序还需要建立两个选项，一个是自动替换所有，一个是对于每一个替换操作都请求确认——需要打印相关信息。

程序需要经过如下几个阶段：1.明确匹配模板  1.1写出字符串模板 匹配操作 给出匹配的所有情况，最好是行模板匹配模式。  最后明确匹配情况 2.明确匹配的文字的后给出情况 





